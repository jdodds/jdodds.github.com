<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: book-runthroughs | Exhortatory]]></title>
  <link href="http://jdodds.github.com/blog/categories/book-runthroughs/atom.xml" rel="self"/>
  <link href="http://jdodds.github.com/"/>
  <updated>2012-09-10T18:25:05-04:00</updated>
  <id>http://jdodds.github.com/</id>
  <author>
    <name><![CDATA[Jeremiah Dodds]]></name>
    <email><![CDATA[jeremiah.dodds@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[tecs - boolean logic 1.1: background]]></title>
    <link href="http://jdodds.github.com/blog/2012/09/10/tecs-boolean-logic-1-dot-1-background/"/>
    <updated>2012-09-10T17:43:00-04:00</updated>
    <id>http://jdodds.github.com/blog/2012/09/10/tecs-boolean-logic-1-dot-1-background</id>
    <content type="html"><![CDATA[<p>This is part of a series of posts going through
<a href="http://www1.idc.ac.il/tecs/">The Elements of Computing Systems</a>. This post
covers the background section of the first chapter, which is about Boolean
Logic.</p>

<!-- more -->


<h2>Boolean Logic</h2>

<p>All digital devices are made of logic gates. In this book, we'll start with a
Nand gate and build the other gates from it.</p>

<h2>Background</h2>

<p>Boolean gates are implementations of Boolean functions.</p>

<h3>Boolean Algebra</h3>

<p>A Boolean function operates on binary inputs and returns binary outputs.</p>

<h4>Truth Table Representation</h4>

<p><code>
| x | y | z | f(x, y, z) |
|---+---+---+------------|
| 0 | 0 | 0 |          0 |
| 0 | 0 | 1 |          0 |
| 0 | 1 | 0 |          1 |
| 0 | 1 | 1 |          0 |
| 1 | 0 | 0 |          1 |
| 1 | 0 | 1 |          0 |
| 1 | 1 | 0 |          1 |
| 1 | 1 | 1 |          0 |
</code></p>

<h4>Boolean Expressions</h4>

<p>The basic operators are "And", "Or", and "Not"</p>

<ul>
<li><code>x * y</code> is "x And y"</li>
<li><code>x + y</code> is "x Or y"</li>
<li><code>!x</code> is "Not x"</li>
</ul>


<p>The table above could be represented as <code>f(x,y,z) = (x + y) * !z</code>.</p>

<h4>Canonical Representation</h4>

<p>Every Boolean function can be expressed as at least one Boolean Expression, the
"canonical representation"</p>

<p>For each row in the function's truth table that has a value of 1, create a term
by <code>And</code>ing literals that "fix" the values of the row's inputs.</p>

<p><code>
| x | y | z | f(x, y, z) |
|---+---+---+------------|
| 0 | 0 | 0 |          0 |
| 0 | 0 | 1 |          0 |
| 0 | 1 | 0 |          1 |
| 0 | 1 | 1 |          0 |
| 1 | 0 | 0 |          1 |
| 1 | 0 | 1 |          0 |
| 1 | 1 | 0 |          1 |
| 1 | 1 | 1 |          0 |
</code></p>

<p>For the third row, the term would be <code>!xy!z</code>. For the fifth, <code>x!y!z</code> and for the
seventh, <code>xy!z</code>. If we <code>Or</code> those three terms together, we'll have a boolean
expression that is equivalent to the given truth table, <code>!xy!z + x!y!z + xy!z</code></p>

<h4>Two-Input Boolean Functions</h4>

<p>The number of Boolean functions that can be defined over <code>n</code> binary variables is
<code>2^2^n</code></p>

<p>There are, therefore, sixteen functions possible over two boolean variables:</p>

<p><code>
| Function    | x               | 0 0 1 1 |
|             | y               | 0 1 0 1 |
|-------------+-----------------+---------|
| Constant 0  | 0               | 0 0 0 0 |
| And         | x * y           | 0 0 0 1 |
| x And Not y | x * !y          | 0 0 1 0 |
| x           | x               | 0 0 1 1 |
| Not x And y | !x * y          | 0 1 0 0 |
| y           | y               | 0 1 0 1 |
| Xor         | x * !y + !x * y | 0 1 1 0 |
| Or          | x + y           | 0 1 1 1 |
| Nor         | !(x + y)        | 1 0 0 0 |
| Equivalence | x * y + !x * y  | 1 0 0 1 |
| Not y       | !y              | 1 0 1 0 |
| If y then x | x + !y          | 1 0 1 1 |
| Not x       | !x              | 1 1 0 0 |
| If x then y | !x + y          | 1 1 0 1 |
| Nand        | !(x * y)        | 1 1 1 0 |
| Constant 1  | 1               | 1 1 1 1 |
</code></p>

<p>Both <code>Nand</code> and <code>Nor</code> are capable of constructing <code>And</code>, <code>Or</code>, and <code>Not</code> without
using any other functions.</p>

<h3>Gate Logic</h3>

<p>A <code>gate</code> is a device that implements a Boolean function. A Boolean function that
operates on <code>n</code> variables and returns <code>m</code> binary results will have <code>n</code> input
pins and <code>m</code> output pins.</p>

<p>Complex gates can be made from more elementary gates, the same way that complex
functions can be made from simpler functions.</p>

<p>Any technology that allows switching and conducting capabilities can be used to
transmit data between gates, they are not intrinsically tied to
electricity. This allows computer scientists to work on a more abstract level.</p>

<h4>Primitive and Composite Gates</h4>

<p>Logic gates can be chained together to create "composite gates". If we wanted to
make a gate that implemented <code>And(a,b,c)</code>, we could do it as <code>And(And(a,b),c)</code>.</p>

<p>If we wanted to implement <code>Xor(a,b)</code>, we could do so as
<code>Or(And(a,Not(b)),And(Not(a),b))</code>.</p>

<p>The function being implemented -- <code>Xor(a,b)</code> or <code>And(a,b,c)</code> -- can only be
represented in one way when referring to it's high-level interface, but the
implementation of that interface -- <code>Or(And(a,Not(b)),And(Not(a),b))</code> or
<code>And(And(a,b),c)</code> -- might be done in many ways. For instance, it's possible to
implement <code>Xor</code> using only four gates rather than five.</p>

<h3>Actual Hardware Construction</h3>

<p>We could, of course, actually acquire hardware and wire it up to test potential
implementations of interfaces needed. This would, however, be rather tedious.</p>

<h3>Hardware Description Language (HDL)</h3>

<p>Hardware designers generally write an HDL (or VHDL) program which can be run in
a simulator and subjected to a bunch of tests and performance measurements.</p>

<p>An HDL definition of a chip consists of a "header" section, and a "parts"
section. The header specifies the chip's interface -- it's name and the names of
it's input and output pins. The parts section describes the names and
connections between the lower-level parts that make up the chip. This requires
that the designer have complete docs of the interfaces of the lower-level parts.</p>

<p>Here's an HDL program describing <code>Xor</code>:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span> (xor.vhdl)</span> <a href='/downloads/code/tecs/boolean-logic/background/xor.vhdl'>download</a></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='vhdl'><span class='line'><span class="n">CHIP</span> <span class="k">Xor</span> <span class="err">{</span>
</span><span class='line'>  <span class="k">in</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">;</span>
</span><span class='line'>  <span class="k">out</span> <span class="k">out</span><span class="p">;</span>
</span><span class='line'>  <span class="n">parts</span><span class="o">:</span>
</span><span class='line'>  <span class="k">Not</span><span class="p">(</span><span class="k">in</span><span class="o">=</span><span class="n">a</span><span class="p">,</span> <span class="k">out</span><span class="o">=</span><span class="n">nota</span><span class="p">);</span>
</span><span class='line'>  <span class="k">Not</span><span class="p">(</span><span class="k">in</span><span class="o">=</span><span class="n">b</span><span class="p">,</span> <span class="k">out</span><span class="o">=</span><span class="n">notb</span><span class="p">);</span>
</span><span class='line'>  <span class="k">And</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="n">notb</span><span class="p">,</span> <span class="k">out</span><span class="o">=</span><span class="n">w1</span><span class="p">);</span>
</span><span class='line'>  <span class="k">And</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="n">nota</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="n">b</span><span class="p">,</span> <span class="k">out</span><span class="o">=</span><span class="n">w2</span><span class="p">);</span>
</span><span class='line'>  <span class="k">Or</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="n">w1</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="n">w2</span><span class="p">,</span> <span class="k">out</span><span class="o">=</span><span class="k">out</span><span class="p">);</span>
</span><span class='line'><span class="err">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Most hardware simulators are designed to be able to run test scripts, here's an
example of one written for Xor:</p>

<p><code>
load Xor.vhdl,
output-list a, b, out;
set a 0, set b 0,
eval, output;
set a 0, set b 1,
eval, output;
set a 1, set b 0,
eval, output;
set a 1, set b 1,
eval, output;
</code></p>

<p>And it's possible output:</p>

<p><code>
| a | b | out |
|---+---+-----|
| 0 | 0 | 0   |
| 0 | 1 | 1   |
| 1 | 0 | 1   |
| 1 | 1 | 0   |
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[TECS: Introduction]]></title>
    <link href="http://jdodds.github.com/blog/2012/09/03/tecs-introduction/"/>
    <updated>2012-09-03T11:29:00-04:00</updated>
    <id>http://jdodds.github.com/blog/2012/09/03/tecs-introduction</id>
    <content type="html"><![CDATA[<p>This starts a series of posts that will follow my progress while reading
<a href="http://www1.idc.ac.il/tecs/">The Elements of Computing Systems</a>, which so far
seems like a very excellent book. I'll be taking notes as I go along and doing
the exercises.</p>

<p>I'm posting these partially as a motivator for myself to finish the book in
entirety, and just in case someone finds them useful.</p>

<p>Anyhow, on to the start of the runthrough. This post just covers the
introductory material.</p>

<!-- more -->


<h2>The World Above</h2>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span> (hello.jack)</span> <a href='/downloads/code/tecs/introduction/hello.jack'>download</a></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">function</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">do</span> <span class="n">Output</span><span class="o">.</span><span class="na">printString</span><span class="o">(</span><span class="s">&quot;Hello, World&quot;</span><span class="o">);</span>
</span><span class='line'>        <span class="k">do</span> <span class="n">Output</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
</span><span class='line'>        <span class="k">return</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>To run something like this, it must be parsed, "understood", and then expressed
in a form that the machine it's being run on can execute -- a process called
"compilation".</p>

<p>The end result of compilation, machine-level code, is an abstraction on top of
some "hardware architecture", which sits on top of a certain "chipset", made up
of logic gates made out of "switching devices" like transistors. That's as far
down the abstraction ladder we'll go.</p>

<h3>Abstractions</h3>

<p>A good modular design implies that you can work on individual modules while
ignoring the rest of the system.</p>

<p>In computer science, abstraction is defined as a statement of what a module
does, ignoring the details of how it does it.</p>

<h3>The World Below</h3>

<p>We're going to take a "bottom-up" approach to describing the systems of
abstraction in a modern computing system, starting with basic logic gates.</p>

<p>Below, we'll survey the book plan in the opposite direction.</p>

<h4>High-Level Language Land</h4>

<p>Where people dream up applications and write software that implements them.</p>

<h4>The Road Down to Hardware Land</h4>

<p>Taking a program and compiling it into the machine language of a target
platform.</p>

<p>Source text s analyzed and grouped into a "parse tree., which is then processed
to create a program written in an intermediate language executable by a
stack-based virtual machine, which outputs a large assembly program which can be
executed by an assembler.</p>

<h4>Hardware Land</h4>

<p>Described with HDL.</p>
]]></content>
  </entry>
  
</feed>
