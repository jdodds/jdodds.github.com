<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Exhortatory]]></title>
  <link href="http://jdodds.github.com/atom.xml" rel="self"/>
  <link href="http://jdodds.github.com/"/>
  <updated>2012-09-03T09:41:46-04:00</updated>
  <id>http://jdodds.github.com/</id>
  <author>
    <name><![CDATA[Jeremiah Dodds]]></name>
    <email><![CDATA[jeremiah.dodds@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[a more in-depth look at how what I'm trying to do is different]]></title>
    <link href="http://jdodds.github.com/blog/2012/09/03/a-more-in-depth-look-at-how-what-im-trying-to-do-is-different/"/>
    <updated>2012-09-03T09:39:00-04:00</updated>
    <id>http://jdodds.github.com/blog/2012/09/03/a-more-in-depth-look-at-how-what-im-trying-to-do-is-different</id>
    <content type="html"><![CDATA[<p>A few days ago, I posted a link to <a href="http://www.reddit.com">reddit</a> about the
<a href="http://www.indiegogo.com/customized-linux">&#8220;Customized Linux&#8221; project I&#8217;m trying to get funded</a>. It
generated
<a href="http://www.reddit.com/r/linux/comments/yx86b/im_trying_to_make_it_easy_for_people_to_generate/">quite a bit of discussion</a>,
which you are, of course, free to read through if you&#8217;re so inclined.</p>

<p>One thing that became clear was that I <strong>really</strong> needed to clarify just what
exactly it is that I want this project to be and why the existing tools that let
people customize Linux ISOs don&#8217;t cut it. I posted
<a href="http://jdodds.github.com/blog/2012/08/27/the-difference-between-my-custom-linux-project-and-existing-tools/">a short attempt at clarification</a>,
but for one it still wasn&#8217;t clear at the level that it needed to be, and for two
I didn&#8217;t even really get a very solid phrasing of the idea in my head until
a few hours after I had posted it.</p>

<p>I&#8217;m hoping that this post will provide a clear and understandable overview of
what I&#8217;d like to accomplish. We&#8217;ll start by taking a look at what the problems
I&#8217;d like to solve are, and then take a look at why existing tools that have
similar functionality aren&#8217;t solving those problems. We&#8217;ll wrap up with a bit of
exposition on how we can go about creating good solutions for those problems.</p>

<!-- more -->


<h2>The Problems</h2>

<p>One of the biggest mistakes I made when launching the indiegogo campaign for
this project was putting a focus on it being something that will create
customized Linux install and installation images. While it does do that, it&#8217;s an
implementation detail, and there are plenty of existing tools that do similar
things.</p>

<p>Let&#8217;s take a look at the problems I&#8217;d like to solve. There are a few major
problems, and this project would solve all of them. As far as I know, there
aren&#8217;t any good existing tools that do so.</p>

<h3>You Should Be Able to Have Your Software and Data Available Anywhere</h3>

<p>We live in a pretty amazing time. According to a lot of people, it&#8217;s the future
&#8211; and it certainly seems that way sometimes. We can communicate with people on
the other side of the globe easily, and there are lots of things that we do
everyday that were only barely imagined by the science fiction authors of the
50s and 60s.</p>

<p>I want to make it so that any computer you use can effectively be <strong>your</strong>
computer with a reboot.</p>

<p>Just about everyone who uses a computer on a regular basis has some set of
programs that they like to use, and some files that they use often or need to
have on hand often. People often have some configuration set up that they
like. Examples of this are instant messaging programs, Dropbox accounts, desktop
backgrounds, Firefox themes, papers they&#8217;re working on for school, and so on.</p>

<p>Personally, I&#8217;ve spent quite a bit of time setting up my computer so that I can
be as productive as possible. Unfortunately this means that working on other
people&#8217;s computers can be painful.</p>

<p>I don&#8217;t think that anyone should have to be in a situation where they don&#8217;t have
access to the setup they want or need. You should be able to plug a USB stick
into a computer, reboot it, and have the environment that you&#8217;re used to and the
files that you want ready to go.</p>

<p>There are some services that attempt to allow this, but they largely focus on
providing <a href="http://en.wikipedia.org/wiki/Cloud_storage">cloud storage</a> of
data.</p>

<h3>Recovery Shouldn&#8217;t Be Hard For People Who Aren&#8217;t Gurus</h3>

<p>Whenever a system gets into an unusable state, say through file corruption or
important files being deleted, or virus infection, it can be very difficult to
get things back into a known stable state.  Apple&#8217;s
<a href="http://www.apple.com/support/timemachine/">Time Machine</a> provides a pretty nice
solution for Mac users, but it can take a very long time, and it&#8217;s not reliable
for every type of issue.</p>

<p>Recovery partitions, like those used by OSX and Windows 7, can help restore the
system to a basic usable state, but don&#8217;t help with much of anything else past
that.</p>

<p>It really shouldn&#8217;t be difficult to get back to <strong>exactly</strong> the setup you want.</p>

<h3>Setting Up a New Machine How You Like It Should Be Incredibly Easy</h3>

<p>This is almost the same issue as recovery, but with a more limited scope. When
you buy a new laptop or desktop, for whatever reason, you shouldn&#8217;t have to do
more than selecting &#8220;install my system&#8221; from a menu (or similar) to have
everything set up the way you want it. As it is, people generally spend a few
months remembering all the little bits and pieces of software that they used to
use, and re-install them as they remember them.</p>

<h2>You Shouldn&#8217;t Need to Know Much of Anything About Computers to Utilize a Solution</h2>

<p>While I&#8217;m planning on implementing this on top of existing tools for a Linux
distribution, it shouldn&#8217;t matter whether or not you even know what that is. For
the vast majority of users, their computer is something that runs some
particular applications, and has some particular files, and perhaps has some
settings on it that help make it &#8220;theirs&#8221;.</p>

<p>Look at the popularity of &#8220;app stores&#8221; like
<a href="http://www.apple.com/osx/apps/app-store.html">the Mac App Store</a>,
<a href="http://www.android.com/apps/">Google Play</a>, and
<a href="https://apps.ubuntu.com/cat/">the Ubuntu apps directory</a>. A large part of the
reason they&#8217;re popular (other than sometimes being the only legitimate way to
get software onto a device) is that they let most users focus on getting
software on their device that fills a particular need. I think that most user&#8217;s
entire computing stack should be capable of being generated in a similar way to
finding and installing a piece of software from an app store.</p>

<p>The vast majority of users don&#8217;t know or care to know about partitioning
schemes, bootloaders, tools like chef, internationalization issues, and a
million other things &#8211; and they <strong>shouldn&#8217;t</strong>. Furthermore, they should still
be able to have everything they want or need available to them wherever they
are, and they should be able to specify what they want without needing to learn
a massive amount of stuff about the way computers work. Ideally, they could be
someone who has never heard of a &#8220;package manager&#8221; before and still be able to
use a service that lets them setup their machine with Firefox and Digsby with their
accounts loaded on them painlessly.</p>

<p>I think that this is can be accomplished by creating a service that focuses on
providing a clean interface to app selection and allowing user-data to be
uploaded/specified and then creates live and install images that contain those
things.</p>

<p>This is possibly the hardest part to convey about what I&#8217;d like to create. The
solution to the problems I&#8217;d like to solve is a technical solution, and I&#8217;m very
used to talking about technical solutions in terms of the implementation of
those solutions, and that type of phrasing just doesn&#8217;t cut it when trying to
show the potential value to someone who hasn&#8217;t spent the last decade of their
life immersing themselves in neckbeard lore.</p>

<p>In short: I don&#8217;t think that <strong>anyone</strong> should have to let out a large mental
sigh when they think about setting up a new computer, nor should they be
inconvenienced by not remembering their laptop as long as there&#8217;s a machine they
can use nearby. All they should need to know is that they can plug the USB stick
they have on their keychain into a machine, do one or two things, and then have
access to what they need or have their new machine set up how they like it.</p>

<h2>Existing Tools and Why They Don&#8217;t Solve The Problems</h2>

<p>Before getting started on this section, I&#8217;d like to mention that I don&#8217;t think
that any of these tools are bad tools. I think they all have their place, and I
think that for the most part they&#8217;re well-done. That said, I don&#8217;t think any of
them solve the problems I&#8217;m trying to solve.</p>

<h3><a href="http://susestudio.com/">SUSE Studio</a></h3>

<p>This is one of the closest things I&#8217;ve seen to being the service I want to
create. It&#8217;s interface is clean, and it works very well &#8211; if you&#8217;re in the set
of people who need it. A major reason that it doesn&#8217;t do what I want to do is
that it requires that the user of it know <strong>a lot</strong> about the underlying
platform.</p>

<p>When you start creating a SUSE Studio &#8220;appliance&#8221;, you see this:</p>

<p><img src="http://jdodds.github.com/images/suse-studio/type-of-application.png"></p>

<p>It&#8217;s a nice interface, and a sane default selection, but there&#8217;s a whole lot of
options there that the average user doesn&#8217;t know anything about. Different
versions of SUSE? Gnome or KDE? A server? 32 or 64 bit?</p>

<p>After selecting images and giving a name to what we want to do, we move on to
software selection:</p>

<p><img src="http://jdodds.github.com/images/suse-studio/software-selection.png"></p>

<p>The same issue presents itself here. What&#8217;s a repository? An RPM? I do think
that this is the sort of thing that should be <em>available</em> for customization by
the user, but I don&#8217;t think it&#8217;s the sort of thing that should appear by
default.</p>

<p>In order to select nethack to be installed, I had to add a repository, then
filter the search results to limit it to the repository I just added because
there were a lot of results for the search.</p>

<p>After adding nethack, we move on to configuration:</p>

<p><img src="http://jdodds.github.com/images/suse-studio/general-configuration.png"></p>

<p>This is really a very nice interface, and is something similar to what I would
expose to a user that wanted to see this stuff. One issue is that when adding a
user and choosing a default shell that hasn&#8217;t been selected prompts you to add
it, I&#8217;d rather take the route of informing the user that it&#8217;s been added.</p>

<p>The only part of this that I&#8217;d expose by default in the service I&#8217;m trying to
make would be allowing the username of the default user to be changed.</p>

<p>The &#8220;Personalize&#8221; section allowing you to upload or choose a logo and background
image is well-done.</p>

<p>The &#8220;Startup&#8221; section asks about runlevels and EULAs the person booting should
have to agree to. This is not something I would expose by default.</p>

<p>There&#8217;s a &#8220;Server&#8221; section (in the setup for the appliance type I chose, the
default one) that would be largely unnecessary for the service I want to
create.</p>

<p>The &#8220;Desktop&#8221; section allows you to choose a user to auto-login and specify
startup programs. This is something I wouldn&#8217;t expose at all by default.</p>

<p>The &#8220;Appliance&#8221; and &#8220;Scripts&#8221; sections all require much more knowledge to know
what to do with than I&#8217;d be comfortable exposing by default, although they do
provide sane default choices.</p>

<p>In the &#8220;Files&#8221; section, I had to manually specify the permissions and ownership
information for the files I wanted to be present, and the interface requires
some knowledge of the Linux Filesystem Hierarchy. Other than that, it&#8217;s
well-done.</p>

<p>The &#8220;Build&#8221; tab provides a bunch of options that aren&#8217;t going to be relevant for
the average user, but the feedback provided while building was very nice. When I
selected an &#8220;ISO&#8221;, I didn&#8217;t realize that I was going to have to click &#8220;build
additional&#8221; to get my ISO, instead of being delivered the raw image that was
selected as a default.</p>

<p>When booting the iso provided, it didn&#8217;t auto-login as the user or login by
default to a graphical interface, both of which were options I selected, and
nethack wouldn&#8217;t run in the live environment due to permissions issues. The
shell interface logged off periodically, and I didn&#8217;t get to the point where I
installed a real environment to check if nethack was there because I have no
idea what I&#8217;m supposed to do to do that, and had already spent about an hour
fiddling around.</p>

<p>In short, minus the ISO not working as expected, SUSE studio is targeted at
people who use and love SUSE, and want to make special-purpose SUSE builds, not
at the problems I&#8217;m trying to solve.</p>

<h3><a href="http://www.slax.org/">slax</a></h3>

<p>Slax is another project that is similar on a high-level, but also suffers from
requiring a lot of knowledge from the user. I also couldn&#8217;t find an obvious way
to add data to the build I made. The iso I generated included nethack in the
live environment, but I didn&#8217;t see an easy way to do a to-disk install.</p>

<h3>Other Tools</h3>

<p>Some other tools that were mentioned that might be similar to what I&#8217;m trying to
do, including <a href="http://fedoraproject.org/wiki/Anaconda">anaconda</a>,
<a href="http://puppylinux.org/wikka/woof">woof</a>, <a href="http://pizza.slitaz.org/">pizza</a>,
<a href="http://www.t2-project.org/">T2</a>, <a href="http://uck.sourceforge.net/">UCK</a>,
<a href="http://www.remastersys.com/">Remastersys</a>, and
<a href="http://sourceforge.net/projects/mylivecd/">MyLiveCD</a>.</p>

<p>All of the above tools require some combination of needing the user to be
already running a (often specific) Linux distro to run and needing the user to
really understand what&#8217;s happening at a lower level. Many of them also don&#8217;t
offer a way to take the applications and user-specified configuration in the
live environment and include them in a to-disk install.</p>

<p>Most of them, if not all of them are trying to solve a different core problem or
problems from the set of problems I&#8217;m trying to solve. They tend to be
explicitly allowing a user to create custom live environments, or create very
fine-grained and specially purposed customizations of specific distributions.</p>

<h3>Summary</h3>

<p>I&#8217;m not aware of any existing tools that address the problems I&#8217;m trying to
address. While my project would have a similar implementation to some of the
tools mentioned, it would have a very different focus.</p>

<h2>Conclusion</h2>

<p>From a technical standpoint, the generation of a media containing some set of
software that allows an installation to be made that has the same applications
and user configuration as the live environment isn&#8217;t incredibly hard to
solve. The challenging technical issues largely stem from the resource-intensive
nature of image generation and hosting. If people want to hear about all that
sooner rather than later, I can write about it.</p>

<p>The other, and larger side of the coin here is focusing on creating an interface
that the average computer user can make use of. I plan on making the initial
interface very close to the interfaces that existing app stores used &#8211; the
focus should be on what applications the user needs to be able to run, and with
what configuration. I&#8217;d like to be as objective about interface issues as
possible, and would be looking at having someone who&#8217;s passionate about
<a href="http://en.wikipedia.org/wiki/User_experience_design">UXD</a>  work on the
interface, and doing <a href="http://en.wikipedia.org/wiki/A/B_testing">A/B Testing</a>
with different interface ideas and before rolling out interface updates to
existing users. I&#8217;m also looking at creating some tools for checking an existing
system for installed software to help create and suggest defaults for
generation.</p>

<p>This is something I&#8217;ve wanted to do, at least on a high level, for almost all of
my time using computers in a non-trivial fashion. I&#8217;ve got the skill to make it
a reality, but I can&#8217;t afford to give it the attention it deserves without
finances. If I was in a better place financially, I&#8217;d fund the development of
this myself &#8211; and if I fail to acquire funding for it in the near future, I&#8217;ll
pursue it if and when I&#8217;m in a place to do so.</p>

<p>That said, it would be absolutely awesome if the community as a whole decided
that this is a service they&#8217;d rather see sooner than later &#8211; if you feel that
way, do us all a big favor and
<a href="http://www.indiegogo.com/customized-linux">support the indiegogo campaign</a>, and
tell other people that you think would be interested!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Difference Between My Custom Linux Project and Existing Tools]]></title>
    <link href="http://jdodds.github.com/blog/2012/08/27/the-difference-between-my-custom-linux-project-and-existing-tools/"/>
    <updated>2012-08-27T20:14:00-04:00</updated>
    <id>http://jdodds.github.com/blog/2012/08/27/the-difference-between-my-custom-linux-project-and-existing-tools</id>
    <content type="html"><![CDATA[<p>From a small bit of discussion on
<a href="http://news.ycombinator.com/item?id=4440894">Hacker News</a> and
<a href="http://www.reddit.com/r/linux/comments/yx86b/im_trying_to_make_it_easy_for_people_to_generate/">reddit</a>,
I thought it would be a good idea to extrapolate a bit on what the differences
are between what I&#8217;m trying to do with my project for
<a href="http://www.indiegogo.com/customized-linux?a=1092744">generating custom linux images</a>
and existing tools like <a href="http://susestudio.com/">SUSE Studio</a> and
<a href="http://puppylinux.org/wikka/woof">woof</a>. In short, what I&#8217;m trying to build has
a very focused scope, and aims to provide a service to people who may not even
know basic things about Linux.</p>

<p>The project I&#8217;m trying to launch has a much more limited scope than a tool like
SUSE Studio &#8211; I&#8217;m trying to focus on making it easy for individual users to
have access to the setup they use on a daily basis, on their personal
machines. SUSE Studio is a well-polished tool, but puts a lot of stuff in your
face by default that the type of user I&#8217;m targeting might not know the first
thing about.</p>

<p>The focus, interface-wise, in my tool is going to be on applications and user
data. While I do plan on allowing people to tweak things at as fine-grained of a
level as they want to, I really want to avoid overwhelming less-technical users
with the potential complexity of everything that can go into a distro.</p>

<p>Tools like woof and other existing scripts for generating ISOs require a fair
amount of knowledge from the end-user. I want to provide something that allows
people to spec everything out if they want to, but will by default provide them
with the software they use in a live environment, and after a fresh install,
even if they are close to entirely ignorant of what&#8217;s going on. This includes
doing things like providing a sane partitioning scheme by default, making sure
that the live and installed environments are the same in the ways that matter,
and setting things up in such a way that it&#8217;s possible for people to create the
environment they want <strong>even if they don&#8217;t even know what a package manager is</strong></p>

<p>I&#8217;m trying to build something that&#8217;s usable by people who aren&#8217;t even close to
being Linux gurus. Ideally, I&#8217;m trying to build something that&#8217;s usable by
people who don&#8217;t know the difference between a web-browser and a bootloader.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Kickstarter's Appeal Process]]></title>
    <link href="http://jdodds.github.com/blog/2012/08/23/kickstarters-appeal-process/"/>
    <updated>2012-08-23T04:47:00-04:00</updated>
    <id>http://jdodds.github.com/blog/2012/08/23/kickstarters-appeal-process</id>
    <content type="html"><![CDATA[<p>One of the reasons that I decided to attempt to maintain
<a href="https://github.com/jdodds/aif">aif</a> was because it&#8217;s very relevant to something
I&#8217;ve wanted to do for a long time &#8211; make it easy to create customized Linux
live and install images that have the setup you want available in the live
environment and immediately after a fresh install.</p>

<p>While I&#8217;m capable of accomplishing that from a technical standpoint, I can&#8217;t
currently afford much of anything, let alone the hosting costs associated with
creating and serving install images &#8211; it&#8217;s intensive in terms of CPU use,
memory, and network usage.</p>

<p>I decided to try to start a <a href="http://www.kickstarter.com/">kickstarter</a> for
funding the project. I spent a good amount of time reviewing their project
guidelines, and figuring out how to take a decent video of both myself talking,
and of a proof-of-concept app doing it&#8217;s thing. When I went to submit it for
review, I had sent out a preview link to quite a few people, and gotten nothing
but positive feedback.</p>

<p>To my surprise, my submission was declined, and the reason given was what looked
like a simple form letter saying that I wasn&#8217;t within their project
guidelines. Kickstarter allows you to appeal for re-approval, which I did, but
they only allow you 500 <em>characters</em> with which to do so, a bit on the short end
if you don&#8217;t provide any feedback as to why a submission is declined.</p>

<p>After submitting the appeal, I received the same form letter back. Exactly the
same.</p>

<p>It&#8217;s a bit aggravating &#8211; I can see how my project would have not been
considered the type of thing that kickstarter is for, but if I was being denied
on a whim, I would have preferred that to be stated explicitly. As it is, it&#8217;s
not hard at all to browse through successfully funded projects that are either
in blatant violation of one of their &#8220;project guidelines&#8221;, or that are at least
as interpretable as such as mine was.</p>

<p>Back in 2011, <a href="http://www.kalzumeus.com/">Patrick McKenzie</a> gave a talk at
Google called
<a href="http://www.youtube.com/watch?v=sFWlmEO6eg0&amp;list=UUtXKDgv1AVoG88PLl8nGXmw">What Engineers Don&#8217;t Know We Don&#8217;t Know About Online Marketing</a>,
where he brought up how incredibly bad the support from Google was when
someone&#8217;s AdWords account would be suspended, and how it was really, <em>really</em> in
their best interests to do something about that. I hope Kickstarter starts
providing more (or any) feedback to people they deny submissions from at some
point, but I suppose we&#8217;ll just have to wait and see.</p>

<p>In any case, I&#8217;ve since taken what would have been my kickstarter campaign, and
started it at <a href="http://www.indiegogo.com/customized-linux">indiegogo</a>. Take a
look at it if you&#8217;re so inclined, or show it to your neckbeard friends. I&#8217;d
really like to bring the idea to fruition.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[setting up a development environment for AIF]]></title>
    <link href="http://jdodds.github.com/blog/2012/08/09/setting-up-a-development-environment-for-aif/"/>
    <updated>2012-08-09T04:17:00-04:00</updated>
    <id>http://jdodds.github.com/blog/2012/08/09/setting-up-a-development-environment-for-aif</id>
    <content type="html"><![CDATA[<p>I&#8217;ve spent the last couple of days setting up a development environment for
working on AIF. In this post, I&#8217;m going to walk you through the setup I came up
with. If you have any suggestions, please let me know &#8211; some of this involves
stuff that I&#8217;m not incredibly well-versed in.</p>

<h2>Prerequisites</h2>

<p>First off, I&#8217;m assuming you&#8217;re working on a machine running
<a href="http://archlinux.org">arch</a>. You&#8217;ll also need a copy of the
<a href="http://www.archlinux.org/download/">latest install media</a> and
<a href="http://git-scm.com/">git</a>, if you don&#8217;t already have that installed.</p>

<p>You&#8217;ll need to have a local checkout of both AIF and libui-sh, a dependency of
AIF:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git clone https://github.com/jdodds/aif
</span><span class='line'>$ git clone https://github.com/Dieterbe/libui-sh</span></code></pre></td></tr></table></div></figure>


<h2>Setting Up a VM</h2>

<p>I&#8217;m using <a href="http://wiki.qemu.org/Main_Page">qemu</a>. As far as I can tell, you
should too. The setup required is quite a bit more involved than the setup
for (for example) <a href="http://www.virtualbox.org">virtualbox</a>, but it&#8217;s a much more
suited tool for what we need to do.</p>

<p>Install qemu:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># pacman -S qemu</span></code></pre></td></tr></table></div></figure>


<p>The first thing you&#8217;ll need to do is create a disk image for qemu to use:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>qemu-img create -f qcow2 ~/vms/aif-testing/base.qcow2 8G</span></code></pre></td></tr></table></div></figure>


<p>If your machine supports <a href="http://www.linux-kvm.org/page/Main_Page">kvm</a>, you&#8217;ll
want to load both the <code>kvm</code> and either the <code>kvm-intel</code> or <code>kvm-amd</code> kernel
modules:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># modprobe kvm && modprobe kvm-intel</span></code></pre></td></tr></table></div></figure>


<p>You&#8217;ll probably want to stick those in <code>MODULES</code> in <code>/etc/rc.conf</code>. You&#8217;ll also
want to add yourself to the <code>kvm</code> group:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># usermod -a -G kvm $USERNAME</span></code></pre></td></tr></table></div></figure>


<p>And then either re-login or run <code>su -</code> in your terminal emulator of choice.</p>

<p>Now we should be able to start arch in our vm. I use a simple script:</p>

<figure class='code'><figcaption><span> (vm-aif)</span> <a href='http://jdodds.github.com/downloads/code/vm-aif'>download</a></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="c">#!/usr/bin/env sh</span>
</span><span class='line'>
</span><span class='line'>qemu-system-x86_64 <span class="se">\</span>
</span><span class='line'>    -enable-kvm <span class="se">\</span>
</span><span class='line'>    -cdrom ~/isos/archlinux-2012.08.04-dual.iso <span class="se">\</span>
</span><span class='line'>    -boot <span class="nv">order</span><span class="o">=</span>d <span class="se">\</span>
</span><span class='line'>    -daemonize <span class="se">\</span>
</span><span class='line'>    -m 2G <span class="se">\</span>
</span><span class='line'>    -k en-us <span class="se">\</span>
</span><span class='line'>    ~/vms/aif-testing/base.qcow2
</span></code></pre></td></tr></table></div></figure>


<p>Stick the above somewhere in <code>$PATH</code> and run it, and you should see something
like this:</p>

<p><img src="http://jdodds.github.com/images/arch-live-splash.png"></p>

<p>Press <code>Ctrl-Alt-Shift-2</code> to get to qemu&#8217;s &#8220;monitor&#8221;. You can do a lot of stuff
from here, but for now you should at least know that:</p>

<ul>
<li><code>quit</code> quits</li>
<li><code>savevm foo</code> creates a snapshot named foo</li>
<li><code>loadvm foo</code> loads the snapshot named foo</li>
<li><code>info snapshots</code> shows information about snapshots</li>
</ul>


<p>Press <code>Ctrl-Alt-Shift-1</code> to get back to the boot screen, and boot. Once you&#8217;re
in, your host machine is available to the vm as <code>10.0.2.2</code>.</p>

<h2>git-daemon</h2>

<p>There are a few ways you could make your working copy of AIF and libui-sh
available to your vm, <code>git-daemon</code> is what I went with. If you have git
installed from arch&#8217;s repos, you should already have it.</p>

<p>I have all the code I actively work on under <code>$HOME/workspace</code>. If you use a
similar setup, modify <code>/etc/conf.d/git-daemon.conf</code> to look something like:</p>

<figure class='code'><figcaption><span> (git-daemon.conf)</span> <a href='http://jdodds.github.com/downloads/code/git-daemon.conf'>download</a></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="c"># path to git repositories served</span>
</span><span class='line'><span class="c"># GIT_REPO=&quot;/srv/git/&quot;</span>
</span><span class='line'><span class="c"># see `man git-daemon` for all available options</span>
</span><span class='line'><span class="c"># $GIT_REPO will be present twice in most configs</span>
</span><span class='line'><span class="nv">GIT_DAEMON_ARGS</span><span class="o">=</span><span class="s2">&quot;--detach --syslog --verbose --user-path&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>The <code>--user-path</code> option allows us to clone from the vm easily later.</p>

<p>Now, start up <code>git-daemon</code>:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># rc.d start git-daemon</span></code></pre></td></tr></table></div></figure>


<p>And then over in your vm, you need to get some basics set up:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># pacman -Sy git binutils dialog make
</span><span class='line'># git clone git://10.0.2.2/~$USERNAME/path/to/aif
</span><span class='line'># git clone git://10.0.2.2/~$USERNME/path/to/libui-sh
</span><span class='line'># cd libui-sh && git checkout -t develop && make install && cd -
</span><span class='line'># cd aif && git checkout -t develop</span></code></pre></td></tr></table></div></figure>


<h3>Take a Snaphot</h3>

<p>At this point, you&#8217;re pretty well set-up in your vm. Switch over to the monitor,
and use <code>savevm</code> to create a snapshot that you can reload later with <code>loadvm</code>.</p>

<h2>Sharing Packages With Your Host Machine</h2>

<p>I ended up using <a href="http://xyne.archlinux.ca/projects/pacserve">pacserve</a> to do
this. Here&#8217;s my <code>/etc/conf.d/pacserved</code>:</p>

<figure class='code'><figcaption><span> (pacserved)</span> <a href='http://jdodds.github.com/downloads/code/pacserved'>download</a></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="c"># Use this array to pass additional arguments to the Pacserve daemon, e.g.</span>
</span><span class='line'><span class="c"># PACSERVED_ARGS=(--multicast --log /var/log/pacserve/pacserve.log)</span>
</span><span class='line'>
</span><span class='line'><span class="c"># See &quot;pacserve --help&quot; for more information.</span>
</span><span class='line'>
</span><span class='line'><span class="c"># The following options are used by the daemon and must not be included in the</span>
</span><span class='line'><span class="c"># array:</span>
</span><span class='line'><span class="c">#</span>
</span><span class='line'><span class="c"># --daemon</span>
</span><span class='line'><span class="c"># --pid-file</span>
</span><span class='line'><span class="c"># --su</span>
</span><span class='line'>
</span><span class='line'><span class="nv">PACSERVED_ARGS</span><span class="o">=(</span>--daemon --log /tmp/pacserve.log<span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>I&#8217;m now considering just mounting the host machine&#8217;s <code>/var/cache/pacman</code> via nfs
or similar, but the code in the experimental branch of AIF assumes the above,
and it works pretty well.</p>

<p>At this point you could <code>loadvm</code> if you need to and:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># make install # assuming you're in the aif checkout on the vm
</span><span class='line'># aif -p automatic -c unofficial/jdd-generic-install-sda-using-host-packages</span></code></pre></td></tr></table></div></figure>


<p>And everything should work. You should be able to reboot into a working arch
system. In fact, if you do this and it doesn&#8217;t work, please let me know.</p>

<h2>(optional) Making AIF Available as a Package on the vm</h2>

<p>This is really only necessary for using or working on<code>aif-test</code>, and is by far
the area where I&#8217;m the least sure of whether I&#8217;m doing stuff right. In the
&#8220;experimental&#8221; branch, there are two PKGBUILD templates in
<code>unofficial/pkgbuild-templates</code>. Here&#8217;s a rundown of what you need to do:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># cd
</span><span class='line'># mkdir -p packages/{aif,libui-sh}
</span><span class='line'># cp aif/unofficial/pkgbuild-templates/PKGBUILD.aif packages/aif/PKGBUILD
</span><span class='line'># cp aif/unofficial/pkgbuild-templates/PKGBUILD.libui-sh packages/libui-sh/PKGBUILD</span></code></pre></td></tr></table></div></figure>


<p>Now, edit the two PKGBUILDS, and set <code>_gitroot</code> to an appropriate value. This
should be the only required edit.</p>

<p>Next:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># cd packages/libui-sh && makepkg --asroot && cd -
</span><span class='line'># cd packages/aif && makepkg --asroot --nodeps && cd -
</span><span class='line'># mkdir repo
</span><span class='line'># repo-add repo/aif.db.tar.gz \
</span><span class='line'>#   packages/libui-sh/libui-sh*.pkg.tar.gz packages/aif/aif*.pkg.tar.gz
</span><span class='line'># cp packages/{libui-sh,aif}/*pkg.tar.gz repo/</span></code></pre></td></tr></table></div></figure>


<p>And now the <code>aif-test</code> scripts should run, and make use of your host&#8217;s
packages. As far as I know, none of them are actually <em>working</em> entirely, and
this entire step is only actually necessary if AIF is a dependency on the vm
after the install finishes in order for <code>aif-test</code> to finish. I haven&#8217;t read
enough of it to know quite yet.</p>

<p>It would also be unnecessary if AIF and libui-sh were still available in the
repos. I don&#8217;t particularly like the PKGBUILD-template idea, even though it
works. If this actually is necessary right now, hopefully it won&#8217;t be for long.</p>

<h2>Basic Development Workflow</h2>

<ul>
<li>Work on your host machine</li>
<li><code>loadvm</code> in qemu monitor</li>
<li><code>git pull</code></li>
<li><code>make install</code></li>
<li>run the part of aif you want to test</li>
</ul>


<h2>Conclusion</h2>

<p>Well, that was a lot of setup, but it also helps keep the feedback loop short,
which is nice. If you&#8217;ve got any suggestions, I&#8217;d love to hear them!</p>

<h2>Updates</h2>

<ul>
<li>Updated on Mon Aug 13 10:05:47 EDT 2012 to fix typo pointed out by Mr Green.</li>
<li>Updated on Mon Aug 13 14:27:49 EDT 2012 to fix erroneous groupadd command
pointed out by Mr Green.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[taking over development of AIF]]></title>
    <link href="http://jdodds.github.com/blog/2012/08/08/taking-over-development-of-aif/"/>
    <updated>2012-08-08T23:05:00-04:00</updated>
    <id>http://jdodds.github.com/blog/2012/08/08/taking-over-development-of-aif</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/Dieterbe">Deiter Plaetinck</a> recently handed
<a href="https://github.com/jdodds/aif">AIF</a>, the <a href="http://archlinux.org">Arch Linux</a>
Installation Framework over to me, I&#8217;m pretty excited about it.</p>

<p>There&#8217;s a lot of work that needs to be done &#8211; AIF is currently fairly
broken. I&#8217;m aiming to fix that, and it looks like some major restructuring will
be in order. There are some other popular installation tools around &#8211;
<a href="http://projects.archlinux.org/archboot.git/">Archboot</a>, and the current tools on
the install disks,
<a href="https://github.com/falconindy/arch-install-scripts">arch install scripts</a>. There
is also work being done on a
<a href="https://github.com/bwrsandman/pyaif">port to python</a>, which I&#8217;m keeping an eye
on.</p>

<p>So far, I have support for <code>grub-bios</code> and <code>syslinux</code> working as bootloaders. I
recently spent a couple of days setting up a development environment for making
testing AIF less of a pain, there will be a post describing that coming soon.</p>

<p>I&#8217;m interested in continuing work on AIF for a few reasons. For one, it&#8217;s really
a pretty nice tool. The ideas that it&#8217;s trying to implement are, at the core,
pretty solid in my opinion. It was also the default installation tool for arch
for quite some time, and people seem to miss it. In addition, I&#8217;ve been wanting
to start contributing back to the arch community for a little while, and I
happen to be working on some tools for making generation of customized Linux
install and live images easy that are partially built on top of AIF.</p>

<p>If you&#8217;d like to help out, patches, advice, and feedback are always welcome.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[First Post]]></title>
    <link href="http://jdodds.github.com/blog/2012/08/08/first-post/"/>
    <updated>2012-08-08T20:40:00-04:00</updated>
    <id>http://jdodds.github.com/blog/2012/08/08/first-post</id>
    <content type="html"><![CDATA[<p>For the first time in a while, I&#8217;m feeling the urge to start writing about the
tech stuff that I do. This seems like a good platform for doing that with, we&#8217;ll
see how it goes.</p>
]]></content>
  </entry>
  
</feed>
